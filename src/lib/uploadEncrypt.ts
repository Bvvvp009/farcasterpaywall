import { ethers } from 'ethers'
import { uploadJSONToIPFS } from './ipfs'
import contractAbi from "../../contracts/contractABI.json"

// Contract addresses - Use environment variables for mainnet
const contentAccessContract = process.env.NEXT_PUBLIC_BASE_LIT_CONTRACT || "0xe7880e2aDd0429296dfFC12cb8c14726fbE5De29";
const usdcTokenAddress = process.env.NEXT_PUBLIC_USDC_CONTRACT_BASE || "0x036CbD53842c5426634e7929541eC2318f3dCF7e";

// ContentAccess Contract ABI
const contentAccessABI = contractAbi

export interface UploadResult {
  success: boolean
  cid: string
  contentId: string
  originalContentId: string
  dataToEncryptHash: string
  originalContent: string
  ciphertext: string
  contentType: string
  creator: string
  price: string
  priceInUSDC: string
  error?: string
}

export async function uploadAndEncrypt(
  contentId: string,
  content: string,
  price: string,
  contentType: string = 'text'
): Promise<UploadResult> {
  try {
    console.log("üöÄ Starting upload and encryption process...")
    console.log("üìù Content ID:", contentId)
    console.log("üí∞ Price:", price, "USDC")
    console.log("üìÑ Content Type:", contentType)

    // Create contract instance
    const provider = new ethers.JsonRpcProvider(process.env.NEXT_PUBLIC_BASE_RPC_URL || "https://sepolia.base.org");
    const wallet = new ethers.Wallet(process.env.NEXT_PUBLIC_PRIVATE_KEY! as `0x${string}`, provider);
    const contentAccessContractInstance = new ethers.Contract(contentAccessContract, contractAbi, wallet);

    console.log("walletClient.address ‚úÖ", wallet.address)
    
    // Generate bytes32 contentId from the string contentId
    const bytes32ContentId = ethers.encodeBytes32String(contentId)
    console.log("Generated bytes32 contentId:", bytes32ContentId)

    // Generate dataToEncryptHash (this will be used for access control)
    const dataToEncryptHash = ethers.keccak256(ethers.toUtf8Bytes(contentId))
    console.log("Generated dataToEncryptHash:", dataToEncryptHash)

    // For now, use a simple encryption placeholder
    // In full implementation, this would use Lit Protocol
    const ciphertext = `encrypted_${content}_${dataToEncryptHash}`
    const encryptedHash = dataToEncryptHash

    console.log("ciphertext ‚úÖ", ciphertext)
    console.log("dataToEncryptHash ‚úÖ", encryptedHash)

    // Upload metadata to IPFS
    const metadata = {
      originalContentId: contentId,
      creator: wallet.address,
      price: price,
      createdAt: new Date().toISOString(),
      contentType: contentType,
      dataToEncryptHash: encryptedHash,
      ciphertext: ciphertext
    }

    const ipfsCid = await uploadJSONToIPFS(metadata)
    const contentUrl = `https://gateway.pinata.cloud/ipfs/${ipfsCid}`
    
    console.log("ipfsCid ‚úÖ", ipfsCid)
    console.log("contentUrl ‚úÖ", contentUrl)

    // Register content on-chain with USDC price
    try {
      // Convert price to USDC units (6 decimals)
      const priceInUSDC = ethers.parseUnits(price, 6)
      
      console.log("Registering content on-chain...")
      console.log("Price in USDC:", price)
      console.log("IPFS CID:", ipfsCid)

      const tx = await contentAccessContractInstance.registerContent(
        bytes32ContentId,
        priceInUSDC,
        ipfsCid
      )

      const receipt = await tx.wait()
      console.log("Content registered on-chain ‚úÖ", receipt.hash)

      return {
        success: true,
        cid: ipfsCid.cid,
        contentId: bytes32ContentId,
        originalContentId: contentId,
        dataToEncryptHash: encryptedHash,
        originalContent: content,
        ciphertext,
        contentType,
        creator: wallet.address,
        price: price,
        priceInUSDC: ethers.parseUnits(price, 6).toString()
      }
    } catch (error) {
      console.error("Failed to register content on-chain:", error)
      throw new Error(`Failed to register content on-chain: ${error}`)
    }
  } catch (error) {
    console.error("Upload and encryption failed:", error)
    return {
      success: false,
      cid: "",
      contentId: "",
      originalContentId: contentId,
      dataToEncryptHash: "",
      originalContent: content,
      ciphertext: "",
      contentType,
      creator: "",
      price: price,
      priceInUSDC: "",
      error: error instanceof Error ? error.message : "Unknown error"
    }
  }
}

export async function payForContentWithUSDC(contentId: string, price: string): Promise<{ success: boolean; txHash?: string; error?: string }> {
  try {
    const provider = new ethers.JsonRpcProvider(process.env.NEXT_PUBLIC_BASE_RPC_URL || "https://sepolia.base.org");
    const wallet = new ethers.Wallet(process.env.NEXT_PUBLIC_PRIVATE_KEY! as `0x${string}`, provider);
    
    const contentAccessContractInstance = new ethers.Contract(contentAccessContract, contentAccessABI, wallet);
    const usdcContract = new ethers.Contract(usdcTokenAddress, [
      "function approve(address spender, uint256 amount) returns (bool)",
      "function balanceOf(address account) view returns (uint256)"
    ], wallet);

    // Convert price to USDC units
    const priceInUSDC = ethers.parseUnits(price, 6);
    
    // Check USDC balance
    const balance = await usdcContract.balanceOf(wallet.address);
    if (balance < priceInUSDC) {
      throw new Error(`Insufficient USDC balance. Required: ${price}, Available: ${ethers.formatUnits(balance, 6)}`);
    }

    // Approve USDC spending
    const approveTx = await usdcContract.approve(contentAccessContract, priceInUSDC);
    await approveTx.wait();

    // Pay for content
    const bytes32ContentId = ethers.encodeBytes32String(contentId);
    const payTx = await contentAccessContractInstance.payForContent(bytes32ContentId);
    const receipt = await payTx.wait();

    return {
      success: true,
      txHash: receipt.hash
    };
  } catch (error) {
    console.error("Payment failed:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Unknown error"
    };
  }
} 